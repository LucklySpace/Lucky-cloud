<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>im-live WebRTC ç›´æ’­ä¸­å¿ƒ</title>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --bg-dark: #0f172a;
            --bg-card: #1e293b;
            --bg-input: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #475569;
            --accent: #22d3ee;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1a2e 50%, #16213e 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }

        /* ç½‘æ ¼èƒŒæ™¯ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(rgba(99, 102, 241, 0.03) 1px, transparent 1px),
            linear-gradient(90deg, rgba(99, 102, 241, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 50%, #a855f7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 40px rgba(99, 102, 241, 0.3);
        }

        header p {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 24px;
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 50px;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .status-item:hover {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--danger);
            transition: all 0.3s;
        }

        .status-dot.connected {
            background: var(--success);
            box-shadow: 0 0 15px var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 320px 1fr 380px;
            gap: 20px;
        }

        .card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--border);
            transition: all 0.3s;
        }

        .card:hover {
            border-color: rgba(99, 102, 241, 0.5);
        }

        .card h3 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card h3::before {
            content: '';
            display: block;
            width: 4px;
            height: 20px;
            background: linear-gradient(180deg, var(--primary) 0%, var(--accent) 100%);
            border-radius: 2px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: inherit;
            transition: all 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
            color: white;
        }

        .btn-secondary {
            background: var(--bg-input);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-accent {
            background: linear-gradient(135deg, var(--accent) 0%, #06b6d4 100%);
            color: var(--bg-dark);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .video-box {
            position: relative;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            aspect-ratio: 16/9;
            border: 2px solid var(--border);
            transition: all 0.3s;
        }

        .video-box:hover {
            border-color: var(--primary);
        }

        .video-box.publishing {
            border-color: var(--success);
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.3);
        }

        .video-box.subscribing {
            border-color: var(--accent);
            box-shadow: 0 0 30px rgba(34, 211, 238, 0.3);
        }

        .video-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .video-label .live-indicator {
            width: 8px;
            height: 8px;
            background: var(--danger);
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        .video-stats {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .log-container {
            height: 350px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.75rem;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid var(--border);
        }

        .log-container::-webkit-scrollbar {
            width: 6px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            display: flex;
            gap: 8px;
        }

        .log-entry.info {
            color: #60a5fa;
        }

        .log-entry.success {
            color: #34d399;
        }

        .log-entry.error {
            color: #f87171;
        }

        .log-entry.warn {
            color: #fbbf24;
        }

        .log-entry .time {
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .log-entry .msg {
            word-break: break-all;
        }

        .user-list, .stream-list {
            max-height: 180px;
            overflow-y: auto;
        }

        .user-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: var(--bg-input);
            border-radius: 10px;
            margin-bottom: 8px;
            transition: all 0.3s;
        }

        .user-item:hover {
            background: rgba(99, 102, 241, 0.1);
        }

        .user-avatar {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--primary) 0%, #a855f7 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .user-role {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .stream-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 14px;
            background: var(--bg-input);
            border-radius: 10px;
            margin-bottom: 8px;
            border: 1px solid transparent;
            transition: all 0.3s;
        }

        .stream-item:hover {
            border-color: var(--primary);
        }

        .stream-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stream-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
        }

        .stream-details {
            font-size: 0.85rem;
        }

        .stream-name {
            font-weight: 600;
        }

        .stream-publisher {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            background: var(--bg-input);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 4px;
        }

        .empty-state {
            color: var(--text-secondary);
            text-align: center;
            padding: 30px;
            font-size: 0.9rem;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tab {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .tab.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .video-container {
                grid-template-columns: 1fr;
            }
        }

        /* åŠ¨ç”»æ•ˆæœ */
        .card {
            animation: slideUp 0.5s ease-out;
            animation-fill-mode: backwards;
        }

        .card:nth-child(1) {
            animation-delay: 0.1s;
        }

        .card:nth-child(2) {
            animation-delay: 0.2s;
        }

        .card:nth-child(3) {
            animation-delay: 0.3s;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>ğŸ¬ im-live ç›´æ’­ä¸­å¿ƒ</h1>
        <p>åŸºäº Netty + WebRTC + è™šæ‹Ÿçº¿ç¨‹çš„é«˜æ€§èƒ½æµåª’ä½“æœåŠ¡å™¨</p>
    </header>

    <div class="status-bar">
        <div class="status-item">
            <div class="status-dot" id="wsStatus"></div>
            <span id="wsStatusText">æœªè¿æ¥</span>
        </div>
        <div class="status-item">
            <span>ğŸ  æˆ¿é—´:</span>
            <span id="currentRoom">-</span>
        </div>
        <div class="status-item">
            <span>ğŸ‘¤ ç”¨æˆ·:</span>
            <span id="currentUser">-</span>
        </div>
        <div class="status-item">
            <span>ğŸ“º çŠ¶æ€:</span>
            <span id="streamStatus">ç©ºé—²</span>
        </div>
    </div>

    <div class="main-grid">
        <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
        <div class="left-panel">
            <div class="card">
                <h3>ğŸ”Œ è¿æ¥è®¾ç½®</h3>
                <div class="form-group">
                    <label>ä¿¡ä»¤æœåŠ¡å™¨åœ°å€</label>
                    <input id="wsUrl" type="text" value="ws://localhost:8082/ws">
                </div>
                <div class="form-group">
                    <label>æˆ¿é—´ ID</label>
                    <input id="roomId" type="text" value="live-room-1">
                </div>
                <div class="form-group">
                    <label>ç”¨æˆ· ID</label>
                    <input id="userId" type="text" value="">
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" id="btnConnect">è¿æ¥</button>
                    <button class="btn btn-danger" disabled id="btnDisconnect">æ–­å¼€</button>
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h3>ğŸšª æˆ¿é—´æ“ä½œ</h3>
                <div class="btn-group">
                    <button class="btn btn-success" disabled id="btnJoin">åŠ å…¥æˆ¿é—´</button>
                    <button class="btn btn-danger" disabled id="btnLeave">ç¦»å¼€æˆ¿é—´</button>
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h3>ğŸ“¡ æ¨æµæ§åˆ¶</h3>
                <div class="form-group">
                    <label>æµ ID</label>
                    <input id="streamId" type="text" value="my-stream">
                </div>
                <div class="form-group">
                    <label>è§†é¢‘æº</label>
                    <select id="videoSource">
                        <option value="camera">æ‘„åƒå¤´</option>
                        <option value="screen">å±å¹•å…±äº«</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn btn-accent" disabled id="btnPublish">ğŸ”´ å¼€å§‹æ¨æµ</button>
                    <button class="btn btn-danger" disabled id="btnUnpublish">â¹ï¸ åœæ­¢æ¨æµ</button>
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h3>ğŸ“Š ç»Ÿè®¡ä¿¡æ¯</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="statUsers">0</div>
                        <div class="stat-label">åœ¨çº¿ç”¨æˆ·</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statStreams">0</div>
                        <div class="stat-label">æ´»è·ƒæµ</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statLatency">-</div>
                        <div class="stat-label">å»¶è¿Ÿ(ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statQps">0</div>
                        <div class="stat-label">QPS</div>
                    </div>
                </div>
                <button class="btn btn-secondary" id="btnStats" style="width: 100%; margin-top: 15px;">è·å–æœåŠ¡å™¨ç»Ÿè®¡
                </button>
            </div>
        </div>

        <!-- ä¸­é—´è§†é¢‘åŒºåŸŸ -->
        <div class="center-panel">
            <div class="card">
                <h3>ğŸ“º è§†é¢‘é¢„è§ˆ</h3>
                <div class="video-container">
                    <div class="video-box" id="localVideoBox">
                        <video autoplay id="localVideo" muted playsinline></video>
                        <div class="video-label">
                            <span class="live-indicator" id="localLiveIndicator" style="display: none;"></span>
                            <span>æœ¬åœ°é¢„è§ˆ</span>
                        </div>
                        <div class="video-stats" id="localVideoStats"></div>
                    </div>
                    <div class="video-box" id="remoteVideoBox">
                        <video autoplay id="remoteVideo" playsinline></video>
                        <div class="video-label">
                            <span class="live-indicator" id="remoteLiveIndicator" style="display: none;"></span>
                            <span id="remoteVideoLabel">è¿œç¨‹è§†é¢‘</span>
                        </div>
                        <div class="video-stats" id="remoteVideoStats"></div>
                    </div>
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h3>ğŸ“‹ æˆ¿é—´å†…æµåˆ—è¡¨</h3>
                <div class="stream-list" id="streamList">
                    <div class="empty-state">æš‚æ— æ¨æµï¼ŒåŠ å…¥æˆ¿é—´åå¯æŸ¥çœ‹</div>
                </div>
            </div>
        </div>

        <!-- å³ä¾§ä¿¡æ¯é¢æ¿ -->
        <div class="right-panel">
            <div class="card">
                <h3>ğŸ‘¥ æˆ¿é—´æˆå‘˜</h3>
                <div class="user-list" id="userList">
                    <div class="empty-state">æš‚æ— ç”¨æˆ·</div>
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h3>ğŸ“ æ—¥å¿—</h3>
                <div class="tabs">
                    <button class="tab active" data-tab="all">å…¨éƒ¨</button>
                    <button class="tab" data-tab="signal">ä¿¡ä»¤</button>
                    <button class="tab" data-tab="webrtc">WebRTC</button>
                </div>
                <div class="log-container" id="logContainer"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // ============================================
    // å…¨å±€çŠ¶æ€
    // ============================================
    let ws = null;
    let localStream = null;
    let peerConnections = new Map();  // streamId -> { pc, targetUserId }
    let roomId = null;
    let userId = null;
    let isInRoom = false;
    let isPublishing = false;
    let myStreamId = null;
    let roomUsers = new Map();
    let roomStreams = new Map();
    let iceServers = [];
    let logFilter = 'all';
    let lastPingTime = 0;

    // ============================================
    // DOM å…ƒç´ 
    // ============================================
    const elements = {
        wsUrl: document.getElementById('wsUrl'),
        roomId: document.getElementById('roomId'),
        userId: document.getElementById('userId'),
        streamId: document.getElementById('streamId'),
        videoSource: document.getElementById('videoSource'),
        btnConnect: document.getElementById('btnConnect'),
        btnDisconnect: document.getElementById('btnDisconnect'),
        btnJoin: document.getElementById('btnJoin'),
        btnLeave: document.getElementById('btnLeave'),
        btnPublish: document.getElementById('btnPublish'),
        btnUnpublish: document.getElementById('btnUnpublish'),
        btnStats: document.getElementById('btnStats'),
        wsStatus: document.getElementById('wsStatus'),
        wsStatusText: document.getElementById('wsStatusText'),
        currentRoom: document.getElementById('currentRoom'),
        currentUser: document.getElementById('currentUser'),
        streamStatus: document.getElementById('streamStatus'),
        localVideo: document.getElementById('localVideo'),
        remoteVideo: document.getElementById('remoteVideo'),
        localVideoBox: document.getElementById('localVideoBox'),
        remoteVideoBox: document.getElementById('remoteVideoBox'),
        localLiveIndicator: document.getElementById('localLiveIndicator'),
        remoteLiveIndicator: document.getElementById('remoteLiveIndicator'),
        remoteVideoLabel: document.getElementById('remoteVideoLabel'),
        localVideoStats: document.getElementById('localVideoStats'),
        remoteVideoStats: document.getElementById('remoteVideoStats'),
        userList: document.getElementById('userList'),
        streamList: document.getElementById('streamList'),
        logContainer: document.getElementById('logContainer'),
        statUsers: document.getElementById('statUsers'),
        statStreams: document.getElementById('statStreams'),
        statLatency: document.getElementById('statLatency'),
        statQps: document.getElementById('statQps')
    };

    // ============================================
    // åˆå§‹åŒ–
    // ============================================
    function init() {
        // ç”Ÿæˆéšæœºç”¨æˆ·ID
        elements.userId.value = 'user_' + Math.random().toString(36).substring(2, 8);
        elements.streamId.value = 'stream_' + Math.random().toString(36).substring(2, 6);

        // ç»‘å®šäº‹ä»¶
        elements.btnConnect.addEventListener('click', connect);
        elements.btnDisconnect.addEventListener('click', disconnect);
        elements.btnJoin.addEventListener('click', joinRoom);
        elements.btnLeave.addEventListener('click', leaveRoom);
        elements.btnPublish.addEventListener('click', publish);
        elements.btnUnpublish.addEventListener('click', unpublish);
        elements.btnStats.addEventListener('click', requestStats);

        // Tab åˆ‡æ¢
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                logFilter = tab.dataset.tab;
                filterLogs();
            });
        });

        log('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', 'info', 'system');
    }

    // ============================================
    // æ—¥å¿—è®°å½•
    // ============================================
    function log(message, type = 'info', category = 'all') {
        const time = new Date().toLocaleTimeString('zh-CN', {hour12: false});
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.dataset.category = category;
        entry.innerHTML = `<span class="time">[${time}]</span><span class="msg">${message}</span>`;

        if (logFilter === 'all' || logFilter === category) {
            entry.style.display = 'flex';
        } else {
            entry.style.display = 'none';
        }

        elements.logContainer.appendChild(entry);
        elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
        console.log(`[${type.toUpperCase()}][${category}] ${message}`);
    }

    function filterLogs() {
        document.querySelectorAll('.log-entry').forEach(entry => {
            const category = entry.dataset.category;
            entry.style.display = (logFilter === 'all' || logFilter === category) ? 'flex' : 'none';
        });
    }

    // ============================================
    // WebSocket è¿æ¥
    // ============================================
    function connect() {
        const url = elements.wsUrl.value;
        log(`æ­£åœ¨è¿æ¥: ${url}...`, 'info', 'signal');

        try {
            ws = new WebSocket(url);

            ws.onopen = () => {
                log('âœ… WebSocket è¿æ¥æˆåŠŸ', 'success', 'signal');
                updateConnectionStatus(true);
                updateButtons();
            };

            ws.onclose = (event) => {
                log(`WebSocket è¿æ¥å·²æ–­å¼€ (code=${event.code})`, 'warn', 'signal');
                updateConnectionStatus(false);
                cleanup();
                updateButtons();
            };

            ws.onerror = (error) => {
                log('âŒ WebSocket è¿æ¥é”™è¯¯', 'error', 'signal');
                console.error(error);
            };

            ws.onmessage = (event) => {
                handleMessage(JSON.parse(event.data));
            };
        } catch (error) {
            log(`è¿æ¥å¤±è´¥: ${error.message}`, 'error', 'signal');
        }
    }

    function disconnect() {
        if (ws) {
            ws.close();
            ws = null;
        }
    }

    function send(message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            const json = JSON.stringify(message);
            ws.send(json);
            log(`ğŸ“¤ ${message.type}`, 'info', 'signal');
        }
    }

    // ============================================
    // æ¶ˆæ¯å¤„ç†
    // ============================================
    function handleMessage(msg) {
        const isError = msg.code !== undefined && msg.code !== 0;
        log(`ğŸ“¥ ${msg.type} ${isError ? '(é”™è¯¯: ' + msg.message + ')' : ''}`,
            isError ? 'error' : 'success', 'signal');

        switch (msg.type) {
            case 'pong':
                const latency = Date.now() - lastPingTime;
                elements.statLatency.textContent = latency;
                break;
            case 'joined':
                handleJoined(msg);
                break;
            case 'left':
                handleLeft(msg);
                break;
            case 'user_joined':
                handleUserJoined(msg);
                break;
            case 'user_left':
                handleUserLeft(msg);
                break;
            case 'published':
                handlePublished(msg);
                break;
            case 'unpublished':
                handleUnpublished(msg);
                break;
            case 'stream_published':
                handleStreamPublished(msg);
                break;
            case 'stream_unpublished':
                handleStreamUnpublished(msg);
                break;
            case 'subscribed':
                handleSubscribed(msg);
                break;
            case 'offer':
                handleOffer(msg);
                break;
            case 'answer':
                handleAnswer(msg);
                break;
            case 'candidate':
                handleCandidate(msg);
                break;
            case 'stats':
                handleStats(msg);
                break;
            case 'error':
                log(`âŒ é”™è¯¯: ${msg.message}`, 'error', 'signal');
                break;
        }
    }

    // ============================================
    // æˆ¿é—´æ“ä½œ
    // ============================================
    function joinRoom() {
        roomId = elements.roomId.value;
        userId = elements.userId.value;

        send({
            type: 'join',
            roomId: roomId,
            userId: userId,
            data: {name: userId}
        });
    }

    function leaveRoom() {
        send({
            type: 'leave',
            roomId: roomId,
            userId: userId
        });
    }

    function handleJoined(msg) {
        if (msg.code === 0) {
            isInRoom = true;
            elements.currentRoom.textContent = roomId;
            elements.currentUser.textContent = userId;

            if (msg.data) {
                if (msg.data.iceServers) {
                    iceServers = msg.data.iceServers;
                    log(`ICE æœåŠ¡å™¨é…ç½®: ${iceServers.length} ä¸ª`, 'info', 'webrtc');
                }
                if (msg.data.room) {
                    updateRoomInfo(msg.data.room);
                }
                // å¤„ç†å·²å­˜åœ¨çš„æµ
                if (msg.data.streams && msg.data.streams.length > 0) {
                    msg.data.streams.forEach(stream => {
                        roomStreams.set(stream.streamId, stream);
                    });
                    updateStreamList();
                    log(`æˆ¿é—´å†…å·²æœ‰ ${msg.data.streams.length} ä¸ªæµ`, 'info', 'signal');
                }
            }

            log(`âœ… æˆåŠŸåŠ å…¥æˆ¿é—´: ${roomId}`, 'success', 'signal');
            updateButtons();
            updateStats();
        } else {
            log(`âŒ åŠ å…¥æˆ¿é—´å¤±è´¥: ${msg.message}`, 'error', 'signal');
        }
    }

    function handleLeft(msg) {
        isInRoom = false;
        isPublishing = false;
        myStreamId = null;
        elements.currentRoom.textContent = '-';
        elements.streamStatus.textContent = 'ç©ºé—²';
        roomUsers.clear();
        roomStreams.clear();
        updateUserList();
        updateStreamList();
        updateButtons();
        updateVideoBoxStyle();
        log('âœ… å·²ç¦»å¼€æˆ¿é—´', 'success', 'signal');
    }

    function handleUserJoined(msg) {
        const userData = msg.data || {};
        roomUsers.set(msg.userId, {...userData, oderId: msg.userId});
        updateUserList();
        updateStats();
        log(`ğŸ‘‹ ç”¨æˆ· ${msg.userId} åŠ å…¥æˆ¿é—´`, 'info', 'signal');
    }

    function handleUserLeft(msg) {
        roomUsers.delete(msg.userId);
        updateUserList();
        updateStats();
        log(`ğŸ‘‹ ç”¨æˆ· ${msg.userId} ç¦»å¼€æˆ¿é—´`, 'info', 'signal');
    }

    // ============================================
    // æ¨æµæ“ä½œ
    // ============================================
    async function publish() {
        try {
            const source = elements.videoSource.value;

            // è·å–æœ¬åœ°åª’ä½“æµ
            if (source === 'camera') {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {width: 1280, height: 720, frameRate: 30},
                    audio: true
                });
            } else {
                localStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {width: 1920, height: 1080, frameRate: 30},
                    audio: true
                });
            }

            elements.localVideo.srcObject = localStream;
            log(`âœ… è·å–${source === 'camera' ? 'æ‘„åƒå¤´' : 'å±å¹•'}åª’ä½“æµæˆåŠŸ`, 'success', 'webrtc');

            myStreamId = elements.streamId.value;

            // å‘é€æ¨æµè¯·æ±‚
            send({
                type: 'publish',
                roomId: roomId,
                userId: userId,
                streamId: myStreamId,
                data: {
                    name: myStreamId,
                    type: source === 'camera' ? 'CAMERA' : 'SCREEN',
                    hasAudio: true,
                    hasVideo: true
                }
            });
        } catch (error) {
            log(`âŒ è·å–åª’ä½“æµå¤±è´¥: ${error.message}`, 'error', 'webrtc');
        }
    }

    function handlePublished(msg) {
        if (msg.code === 0) {
            isPublishing = true;
            elements.streamStatus.textContent = 'æ¨æµä¸­';
            elements.localLiveIndicator.style.display = 'block';
            elements.localVideoBox.classList.add('publishing');
            updateButtons();
            updateStats();
            log(`ğŸ”´ æ¨æµæˆåŠŸ: ${msg.streamId}`, 'success', 'signal');
        } else {
            log(`âŒ æ¨æµå¤±è´¥: ${msg.message}`, 'error', 'signal');
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                elements.localVideo.srcObject = null;
            }
        }
    }

    function unpublish() {
        send({
            type: 'unpublish',
            roomId: roomId,
            userId: userId,
            streamId: myStreamId
        });

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
            elements.localVideo.srcObject = null;
        }

        elements.localLiveIndicator.style.display = 'none';
        elements.localVideoBox.classList.remove('publishing');
    }

    function handleUnpublished(msg) {
        isPublishing = false;
        myStreamId = null;
        elements.streamStatus.textContent = 'ç©ºé—²';
        updateButtons();
        updateStats();
        log('â¹ï¸ åœæ­¢æ¨æµæˆåŠŸ', 'success', 'signal');
    }

    // ============================================
    // æµäº‹ä»¶å¤„ç†
    // ============================================
    function handleStreamPublished(msg) {
        roomStreams.set(msg.streamId, msg.data);
        updateStreamList();
        updateStats();
        log(`ğŸ“º æ–°æµå‘å¸ƒ: ${msg.streamId} (æ¥è‡ª ${msg.userId})`, 'info', 'signal');
    }

    function handleStreamUnpublished(msg) {
        roomStreams.delete(msg.streamId);
        updateStreamList();
        updateStats();
        log(`ğŸ“º æµå·²åœæ­¢: ${msg.streamId}`, 'info', 'signal');

        // å…³é—­ç›¸å…³çš„ PeerConnection
        const pcInfo = peerConnections.get(msg.streamId);
        if (pcInfo) {
            pcInfo.pc.close();
            peerConnections.delete(msg.streamId);
            elements.remoteVideo.srcObject = null;
            elements.remoteLiveIndicator.style.display = 'none';
            elements.remoteVideoBox.classList.remove('subscribing');
            elements.remoteVideoLabel.textContent = 'è¿œç¨‹è§†é¢‘';
        }
    }

    // ============================================
    // è®¢é˜…æµ
    // ============================================
    function subscribeStream(streamId, publisherId) {
        log(`ğŸ”— è®¢é˜…æµ: ${streamId}`, 'info', 'signal');

        send({
            type: 'subscribe',
            roomId: roomId,
            userId: userId,
            streamId: streamId
        });
    }

    async function handleSubscribed(msg) {
        if (msg.code === 0) {
            log(`âœ… è®¢é˜…æˆåŠŸ: ${msg.streamId}`, 'success', 'signal');

            const publisherId = msg.data.publisherId;
            elements.remoteVideoLabel.textContent = `æ¥è‡ª: ${publisherId}`;

            // åˆ›å»º PeerConnection
            const pc = createPeerConnection(msg.streamId, publisherId);
            peerConnections.set(msg.streamId, {pc, targetUserId: publisherId});

            // åˆ›å»º Offer
            try {
                const offer = await pc.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                await pc.setLocalDescription(offer);

                send({
                    type: 'offer',
                    roomId: roomId,
                    userId: userId,
                    targetId: publisherId,
                    streamId: msg.streamId,
                    sdp: offer
                });
                log('ğŸ“¤ å‘é€ Offer', 'info', 'webrtc');
            } catch (error) {
                log(`âŒ åˆ›å»º Offer å¤±è´¥: ${error.message}`, 'error', 'webrtc');
            }
        } else {
            log(`âŒ è®¢é˜…å¤±è´¥: ${msg.message}`, 'error', 'signal');
        }
    }

    // ============================================
    // WebRTC è¿æ¥
    // ============================================
    function createPeerConnection(streamId, remoteUserId) {
        const config = {
            iceServers: iceServers,
            iceCandidatePoolSize: 10
        };
        const pc = new RTCPeerConnection(config);

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                send({
                    type: 'candidate',
                    roomId: roomId,
                    userId: userId,
                    targetId: remoteUserId,
                    streamId: streamId,
                    candidate: event.candidate
                });
            }
        };

        pc.ontrack = (event) => {
            log(`ğŸ“¥ æ”¶åˆ°è¿œç¨‹åª’ä½“æµ`, 'success', 'webrtc');
            elements.remoteVideo.srcObject = event.streams[0];
            elements.remoteLiveIndicator.style.display = 'block';
            elements.remoteVideoBox.classList.add('subscribing');
        };

        pc.onconnectionstatechange = () => {
            log(`ğŸ”— è¿æ¥çŠ¶æ€: ${pc.connectionState}`, 'info', 'webrtc');

            // æŠ¥å‘Šè¿æ¥çŠ¶æ€ç»™æœåŠ¡å™¨
            send({
                type: 'connection_state',
                roomId: roomId,
                userId: userId,
                streamId: streamId,
                data: {
                    state: pc.connectionState,
                    iceState: pc.iceConnectionState
                }
            });
        };

        pc.oniceconnectionstatechange = () => {
            log(`ğŸ§Š ICE çŠ¶æ€: ${pc.iceConnectionState}`, 'info', 'webrtc');
        };

        // å¦‚æœæˆ‘ä»¬æ˜¯æ¨æµæ–¹ï¼Œæ·»åŠ æœ¬åœ°æµ
        if (localStream && isPublishing) {
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });
            log('æ·»åŠ æœ¬åœ°åª’ä½“è½¨é“åˆ° PeerConnection', 'info', 'webrtc');
        }

        return pc;
    }

    async function handleOffer(msg) {
        log(`ğŸ“¥ æ”¶åˆ° Offer (æ¥è‡ª ${msg.userId})`, 'info', 'webrtc');

        let pcInfo = peerConnections.get(msg.streamId);
        if (!pcInfo) {
            const pc = createPeerConnection(msg.streamId, msg.userId);
            pcInfo = {pc, targetUserId: msg.userId};
            peerConnections.set(msg.streamId, pcInfo);
        }

        try {
            await pcInfo.pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
            const answer = await pcInfo.pc.createAnswer();
            await pcInfo.pc.setLocalDescription(answer);

            send({
                type: 'answer',
                roomId: roomId,
                userId: userId,
                targetId: msg.userId,
                streamId: msg.streamId,
                sdp: answer
            });
            log('ğŸ“¤ å‘é€ Answer', 'info', 'webrtc');
        } catch (error) {
            log(`âŒ å¤„ç† Offer å¤±è´¥: ${error.message}`, 'error', 'webrtc');
        }
    }

    async function handleAnswer(msg) {
        log(`ğŸ“¥ æ”¶åˆ° Answer (æ¥è‡ª ${msg.userId})`, 'info', 'webrtc');

        const pcInfo = peerConnections.get(msg.streamId);
        if (pcInfo) {
            try {
                await pcInfo.pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                log('âœ… Answer å¤„ç†æˆåŠŸ', 'success', 'webrtc');
            } catch (error) {
                log(`âŒ å¤„ç† Answer å¤±è´¥: ${error.message}`, 'error', 'webrtc');
            }
        }
    }

    async function handleCandidate(msg) {
        const pcInfo = peerConnections.get(msg.streamId);
        if (pcInfo) {
            try {
                await pcInfo.pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
            } catch (error) {
                log(`âŒ æ·»åŠ  ICE Candidate å¤±è´¥: ${error.message}`, 'error', 'webrtc');
            }
        }
    }

    // ============================================
    // ç»Ÿè®¡ä¿¡æ¯
    // ============================================
    function requestStats() {
        send({type: 'stats'});
    }

    function handleStats(msg) {
        if (msg.code === 0 && msg.data) {
            const {qos, forwarder, connections} = msg.data;
            log(`ğŸ“Š æœåŠ¡å™¨ç»Ÿè®¡: QPS=${qos.qps}, æ´»è·ƒè¿æ¥=${connections.activeConnections}`, 'info', 'signal');

            if (qos) {
                elements.statQps.textContent = qos.qps || 0;
            }
        }
    }

    // ============================================
    // UI æ›´æ–°
    // ============================================
    function updateRoomInfo(room) {
        if (room.users) {
            room.users.forEach(uid => {
                roomUsers.set(uid, {userId: uid});
            });
            updateUserList();
        }
        if (room.streams) {
            room.streams.forEach(sid => {
                roomStreams.set(sid, {streamId: sid});
            });
            updateStreamList();
        }
        updateStats();
    }

    function updateUserList() {
        if (roomUsers.size === 0) {
            elements.userList.innerHTML = '<div class="empty-state">æš‚æ— ç”¨æˆ·</div>';
            return;
        }

        elements.userList.innerHTML = '';
        roomUsers.forEach((user, id) => {
            const isMe = id === userId;
            const isPublisher = roomStreams.has(id) ||
                Array.from(roomStreams.values()).some(s => s.publisherId === id);

            const div = document.createElement('div');
            div.className = 'user-item';
            div.innerHTML = `
                    <div class="user-avatar">${id.charAt(0).toUpperCase()}</div>
                    <div class="user-info">
                        <div class="user-name">${id}${isMe ? ' (æˆ‘)' : ''}</div>
                        <div class="user-role">${isPublisher ? 'ğŸ¥ ä¸»æ’­' : 'ğŸ‘€ è§‚ä¼—'}</div>
                    </div>
                `;
            elements.userList.appendChild(div);
        });
    }

    function updateStreamList() {
        if (roomStreams.size === 0) {
            elements.streamList.innerHTML = '<div class="empty-state">æš‚æ— æ¨æµï¼ŒåŠ å…¥æˆ¿é—´åå¯æŸ¥çœ‹</div>';
            return;
        }

        elements.streamList.innerHTML = '';
        roomStreams.forEach((stream, sid) => {
            const publisherId = stream.publisherId || 'unknown';
            const isMine = publisherId === userId;
            const div = document.createElement('div');
            div.className = 'stream-item';
            div.innerHTML = `
                    <div class="stream-info">
                        <div class="stream-icon">ğŸ“¹</div>
                        <div class="stream-details">
                            <div class="stream-name">${sid}</div>
                            <div class="stream-publisher">å‘å¸ƒè€…: ${publisherId}</div>
                        </div>
                    </div>
                    ${!isMine ? `<button class="btn btn-accent" onclick="subscribeStream('${sid}', '${publisherId}')">è®¢é˜…</button>` : '<span style="color: var(--success)">æˆ‘çš„æµ</span>'}
                `;
            elements.streamList.appendChild(div);
        });
    }

    function updateStats() {
        elements.statUsers.textContent = roomUsers.size;
        elements.statStreams.textContent = roomStreams.size;
    }

    function updateConnectionStatus(connected) {
        elements.wsStatus.classList.toggle('connected', connected);
        elements.wsStatusText.textContent = connected ? 'å·²è¿æ¥' : 'æœªè¿æ¥';
    }

    function updateVideoBoxStyle() {
        elements.localVideoBox.classList.remove('publishing');
        elements.remoteVideoBox.classList.remove('subscribing');
    }

    function updateButtons() {
        const connected = ws && ws.readyState === WebSocket.OPEN;

        elements.btnConnect.disabled = connected;
        elements.btnDisconnect.disabled = !connected;
        elements.btnJoin.disabled = !connected || isInRoom;
        elements.btnLeave.disabled = !connected || !isInRoom;
        elements.btnPublish.disabled = !connected || !isInRoom || isPublishing;
        elements.btnUnpublish.disabled = !connected || !isInRoom || !isPublishing;
        elements.btnStats.disabled = !connected;
    }

    function cleanup() {
        isInRoom = false;
        isPublishing = false;
        myStreamId = null;
        roomUsers.clear();
        roomStreams.clear();

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
            elements.localVideo.srcObject = null;
        }

        peerConnections.forEach(pcInfo => pcInfo.pc.close());
        peerConnections.clear();

        elements.remoteVideo.srcObject = null;
        elements.currentRoom.textContent = '-';
        elements.currentUser.textContent = '-';
        elements.streamStatus.textContent = 'ç©ºé—²';
        elements.localLiveIndicator.style.display = 'none';
        elements.remoteLiveIndicator.style.display = 'none';

        updateUserList();
        updateStreamList();
        updateStats();
        updateButtons();
        updateVideoBoxStyle();
    }

    // ============================================
    // å¿ƒè·³
    // ============================================
    setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
            lastPingTime = Date.now();
            send({type: 'heartbeat'});
        }
    }, 30000);

    // ============================================
    // åˆå§‹åŒ–
    // ============================================
    init();
</script>
</body>
</html>
